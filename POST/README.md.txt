# Универсальный парсер JSON в CSV и XLSX

## Задача и ТЗ

Программа предназначена для пакетного преобразования произвольных JSON-файлов в табличный вид:

- **CSV** — отдельный CSV-файл на каждый входной JSON (в папке `OUT`), имена с таймштампом.
- **XLSX** — один файл `output_YYYYMMDD-HHMM.xlsx` с несколькими листами: каждый обработанный JSON выводится на свой лист.

Требования: универсальность структуры JSON, настраиваемые имена колонок (path_start, exclude_keys, include_only_keys), заморозка областей и форматирование в XLSX, логирование (INFO/DEBUG), параллельная обработка, только стандартная библиотека Python (без pip).

---

## Требования к среде (без pip install)

Проект **не использует сторонние пакеты**. Достаточно:

- **Python 3.7+** из официальной поставки (python.org) или **Anaconda 3.10** (и любых версий Anaconda с Python 3.7+). Установка дополнительных модулей через `pip install` **запрещена и не требуется**.

Используются только модули стандартной библиотеки:

| Модуль | Назначение |
|--------|------------|
| `json` | Чтение и разбор JSON. |
| `csv` | Запись CSV. |
| `logging` | Логирование. |
| `pathlib` | Работа с путями. |
| `typing` | Аннотации типов. |
| `datetime` | Таймштамп в именах файлов. |
| `multiprocessing` | Параллельная обработка файлов. |
| `zipfile` | Сборка XLSX (архив). |
| `xml.etree.ElementTree` | Формирование XML листов и стилей XLSX. |
| `re` | Имена листов, экранирование. |
| `sys` | Путь в тестах. |

Файла `requirements.txt` в проекте нет — зависимости из стандартной библиотеки не перечисляются.

---

## Что делает программа (пошагово)

1. **Чтение конфига** — из `config.json` загружаются пути (`input_dir`, `output_dir`), список файлов (из массива `files[]` или из `input_files`), параметры разбора и экспорта (CSV, XLSX).
2. **Обработка каждого файла** (параллельно или последовательно):
   - JSON читается из `input_dir`/`имя_файла`;
   - определяется массив «строк» (записей) — см. раздел про `extract_rows`;
   - каждая запись разворачивается в плоский словарь (flatten) с учётом `path_start`/`path_starts`, `exclude_keys`, `exclude_keys_in_path`, `include_only_keys`;
   - формируется общий список колонок по всем строкам (порядок: по ключам, внутри массива объектов — (1), (2), (3)…);
   - таблица записывается в CSV в `output_dir` с именем `{имя_файла}_{таймштамп}.csv`;
   - для XLSX возвращаются данные листа: имя листа, строки, колонки.
3. **Сборка XLSX** — один файл `output_{таймштамп}.xlsx` с листом на каждый обработанный JSON; к листам применяются настройки из `xlsx.sheets` (имя, ширина колонок, закрепление, стили заголовка и данных).
4. **Логи** пишутся в папку `log` (INFO и DEBUG с указанием функции/класса).

---

## Структура проекта

```
.
├── config.json          # Конфигурация; блок __comments — пояснения и варианты
├── main.py              # Точка входа
├── IN/                  # Входные JSON-файлы
├── OUT/                 # Результаты: CSV и output_YYYYMMDD-HHMM.xlsx
├── log/                 # Логи INFO и DEBUG
├── src/
│   ├── config_loader.py # Загрузка config.json, get_sheet_options
│   ├── csv_exporter.py  # Запись CSV
│   ├── json_flattener.py# Развёртывание JSON (path_start/path_starts, exclude_keys, exclude_keys_in_path, массивы объектов (1),(2)…)
│   ├── logging_setup.py # Настройка логов
│   ├── worker.py        # Обработка одного файла (flatten + CSV)
│   ├── xlsx_exporter.py # Запись XLSX (стили, выравнивание, форматы колонок)
│   └── Tests/
│       └── test_flattener.py
└── README.md
```

---

## Функции (подробно)

### main.py

- **`main()`**  
  Точка входа: настраивает логирование, загружает конфиг, формирует список файлов из `input_dir` по `input_files`, запускает обработку (пул процессов или цикл), собирает данные листов и вызывает `xlsx_exporter.write_xlsx`. При отсутствии файлов или папки завершает работу с сообщением в лог.

- **`_process_one_file_standalone(json_path_str, base_dir_str, config)`**  
  Обёртка для дочернего процесса: вызывает `worker.process_one_file`, возвращает `(имя_листа, строки, колонки)`. Используется в `multiprocessing.Pool.starmap`.

---

### src.config_loader

- **`load_config(config_path=None)`**  
  Загружает `config.json` по пути (по умолчанию — корень проекта). При ошибке или отсутствии файла возвращает конфиг по умолчанию с пустым `input_files`. Объединяет вложенные секции `csv` и `xlsx` с дефолтами (`DEFAULT_CSV`, `DEFAULT_XLSX`). Возвращает словарь с ключами: `input_dir`, `output_dir`, `input_files`, `files`, `path_separator`, `path_start`, `exclude_keys`, `exclude_keys_in_path`, `include_only_keys`, `csv`, `xlsx`, `column_formats`.

- **`get_files_list(config)`**  
  Возвращает список имён файлов для обработки: если задан массив `config["files"]` — из `files[].file`, иначе из `config["input_files"]`. Только имена файлов (без пути).

- **`get_file_options(config, file_index)`**  
  Возвращает настройки разбора для файла с индексом `file_index`: path_start, path_starts, exclude_keys, exclude_keys_in_path, include_only_keys, column_order, output, sheet_name. Берутся из элемента `config["files"][file_index]` с подстановкой глобальных значений при отсутствии в элементе.

- **`get_sheet_options(config, file_index)`**  
  Возвращает настройки листа XLSX для файла с индексом `file_index` из `config["xlsx"]["sheets"]`. Если листов меньше, чем файлов, повторяется первый лист с подстановкой имени. Возвращаемый словарь содержит `name`, `columns`, `default_column_format`, `column_format`.

---

### src.json_flattener

- **`extract_rows(data)`**  
  Определяет массив записей (строк таблицы) по структуре JSON. Если корень — массив, возвращает его. Если корень — объект, ищет ключи `results`, `data`, `items`, `rows`; если значение — массив, возвращает его. Иначе возвращает список из одного элемента `[data]`.  
  *Пример:* `{"data": {"body": [...]}}` — массив не на верхнем уровне; для извлечения строк используется `path_start: ["data", "body"]` при обходе.

- **`flatten_row(row, path_sep, exclude_keys, exclude_keys_in_path)`**  
  Разворачивает один объект (словарь) в плоский словарь «имя колонки → значение». Имя колонки = путь ключей через `path_sep` (например `"key1 - key2"`). Рекурсивно обходит вложенные объекты и массивы; скаляры записываются в ячейку, массивы примитивов — в строку через запятую, **массивы объектов** — в отдельные колонки с суффиксом ` - (1)`, ` - (2)` и т.д. Ключи из `exclude_keys` (по имени или по полному пути) пропускаются. **`exclude_keys_in_path`** — список правил `{"path": "имя_пути", "keys": ["key1", "key2"]}`: указанные ключи исключаются только внутри этого пути (в т.ч. внутри элементов массива объектов с таким именем, например `id` только в `agileManagers`, но не в `agileTree`).

- **`flatten_json_data(data, path_sep, path_start, path_starts, exclude_keys, exclude_keys_in_path, include_only_keys, column_order)`**  
  Полный разворот: извлекает строки через `extract_rows`, при наличии `path_starts` первый путь — источник строк, остальные мержатся в строку с префиксом; при одном `path_start` — спуск по цепочке. Разворачивает каждую запись с учётом `exclude_keys` и `exclude_keys_in_path`. Объединяет колонки по всем строкам, сортирует их: сначала по первому сегменту пути (ключу), внутри ключа для колонок из массивов объектов — по индексу (1), (2), (3)…; при непустом `include_only_keys` оставляет только указанные колонки; при заданном `column_order` выставляет указанные колонки первыми. Возвращает `(rows, columns)`.

- **`load_and_flatten(json_path, path_sep, path_start, path_starts, exclude_keys, exclude_keys_in_path, include_only_keys, column_order, logger)`**  
  Читает JSON из файла, вызывает `flatten_json_data` с переданными параметрами, логирует число строк и колонок. Возвращает `(rows, columns)`.

---

### src.csv_exporter

- **`write_csv(rows, columns, out_path, encoding=..., delimiter=..., lineterminator=..., logger=...)`**  
  Записывает таблицу в CSV: первая строка — заголовки (`columns`), далее по одной строке на элемент `rows`. Значения берутся как `row.get(col, "")` в порядке колонок. Создаёт родительскую папку при необходимости. По умолчанию `encoding="utf-8-sig"` (BOM для Excel), `delimiter=";"`, `lineterminator="\n"`.

---

### src.xlsx_exporter

- **`write_xlsx(sheets_data, out_path, freeze_first_row, freeze_cell, freeze_cell_per_sheet, autofilter, column_width_mode, auto_row_height, column_widths, column_formats_per_sheet, default_formats_per_sheet, logger)`**  
  Записывает один XLSX с несколькими листами. `sheets_data` — список кортежей `(имя_листа, rows, columns)`. Собирает общую таблицу shared strings, строит для каждого листа XML листа (заголовок, строки данных, закрепление, автофильтр, ширина колонок, высота строк при `auto_row_height`). Стили (шрифты, заливки, выравнивание) берутся из `default_formats_per_sheet[0]` и применяются к заголовку и ячейкам данных; для колонок из `column_formats_per_sheet` применяется `number_format: "integer"` где задано. **Обработка исключений:** если значение ячейки не удаётся преобразовать в указанный тип формата колонки (например, в колонке с форматом integer лежит текст или нечисловая строка), ячейка записывается как значение по умолчанию (текст) и со стилем по умолчанию/данных, без применения формата колонки. В ZIP попадают `[Content_Types].xml`, `xl/workbook.xml`, `xl/styles.xml`, `xl/sharedStrings.xml`, `xl/worksheets/sheetN.xml`.

Вспомогательные функции (внутри модуля):

- **`_normalize_horizontal(value)`** — приводит значение из конфига к OOXML: `left` | `center` | `right` (по умолчанию `left`).
- **`_normalize_vertical(value)`** — приводит к OOXML: `top` | `center` | `bottom` (по умолчанию `center`).
- **`_column_auto_widths(...)`** — вычисляет ширину колонок по содержимому в пределах `width_min`..`width_max`.
- **`_row_auto_heights(...)`** — при `wrap_text` вычисляет высоту строк по числу переносов.
- **`_to_integer_value(val)`** — приводит значение к числу для формата «целое число» в ячейке; при неудаче возвращает `None` (тогда ячейка записывается как текст по умолчанию).

---

### src.worker

- **`process_one_file(json_path, base_dir, config, logger)`**  
  Обрабатывает один JSON: вызывает `json_flattener.load_and_flatten` с параметрами из конфига, записывает CSV через `csv_exporter.write_csv` в `output_dir` с именем `{stem}_{run_timestamp}.csv`. Возвращает `(имя_листа, rows, columns, путь_к_csv)`.

---

## Конфиг (config.json) — подробно с примерами

Конфиг задаёт источники данных, правила разбора JSON и параметры вывода CSV/XLSX. Блок **`__comments`** программой не используется — это справочник по параметрам.

---

### Входные данные и разбор

| Параметр | Тип | Примеры | Влияние на результат |
|----------|-----|---------|----------------------|
| **input_dir** | строка | `"IN"`, `"input"`, `"data/json"` | Папка, из которой читаются JSON-файлы по именам из `input_files`. |
| **output_dir** | строка | `"OUT"`, `"export"` | Папка для CSV и одного XLSX. Создаётся при записи. |
| **input_files** | массив строк | `["file1.json"]`, `["a.json","b.json"]` | Список имён файлов без пути. Обрабатываются только существующие в `input_dir`. |
| **path_separator** | строка | `" - "`, `"|"`, `"."`, `"__"` | Разделитель между ключами в имени колонки. Например при пути `a.b.c` и разделителе `" - "` колонка будет `a - b - c`. |
| **path_start** | массив строк | `[]`, `["data","body"]`, `["results","item"]` | Цепочка ключей, с которой начинать разбор. Имена колонок и данные строятся от этого поддерева; префикс «data - body -» в именах колонок не появляется. Если в записи путь не найден, строка разворачивается от корня записи. |
| **exclude_keys** | массив строк | `[]`, `["photoData"]`, `["colorCode - secondary"]` | Ключи или полные пути (после path_start), которые не попадают в выход. По имени ключа исключается весь поддерево по этому ключу; по пути — только эта ветка. |
| **include_only_keys** | массив строк | `[]`, `["firstName","lastName","employeeNumber"]` | Если не пусто — в выход идут только эти колонки (имена после path_start). Пустой массив = все колонки с учётом exclude_keys. |

**Пример влияния path_start:**

- JSON: `{"data":{"body":[{"name":"A","meta":{"id":1}}]}}`, `path_start: ["data","body"]` → строки из `body`, колонки `name`, `meta - id`.
- Тот же JSON, `path_start: []` → одна строка, колонки вида `data - body - 0 - name`, `data - body - 0 - meta - id` (если extract_rows вернёт массив по ключу `data` и т.д., зависит от структуры).

---

### Настройки по файлам (опционально)

Если в конфиге задан массив **`files`**, список обрабатываемых файлов и часть настроек берутся из него (по одному элементу на файл). Если `files` не задан, используются глобальные `input_files`, `path_start`, `exclude_keys` и т.д., как раньше.

Каждый элемент **`files[]`** может содержать:

| Параметр | Примеры | Влияние |
|----------|---------|---------|
| **file** | `"profiles.json"` | Имя файла из input_dir (обязательное поле в элементе). |
| **sheet_name** | `"Профили"`, `"Лист A"` | Имя листа в XLSX для этого файла (до 31 символа). Если не задано — из имени файла. |
| **output** | `["csv"]`, `["xlsx"]`, `["csv","xlsx"]` | Какие выходы создавать: только CSV, только XLSX или оба (по умолчанию оба). |
| **path_start** | `["data","body"]` | Стартовая цепочка ключей для этого файла (переопределяет глобальный path_start). |
| **path_starts** | `[["data","body"],["data","body","absences"]]` | Несколько стартов: первый — источник строк, остальные — доп. данные мержатся в каждую строку с префиксом (например колонки `absences - isLong`, `absences - info`). |
| **exclude_keys** | `["photoData","info"]` | Исключаемые ключи для этого файла (переопределяет глобальный exclude_keys). |
| **exclude_keys_in_path** | `[{"path":"full","keys":["info"]}, {"path":"agileManagers","keys":["id"]}]` | Исключать указанные ключи только внутри заданного пути. Работает и во вложенных объектах, и **внутри массивов объектов**: `path` — имя поля-массива (например `agileManagers`, `emails`), `keys` — поля элементов массива или вложенного объекта. Так можно убрать `id` только в `agileManagers`, оставив `id` в `agileTree`. |
| **column_order** | `["empName","empFamilyName","jobTitle"]` | Порядок колонок на листе: сначала перечисленные, затем остальные (с сохранением порядка по ключам и (1),(2),(3) для массивов объектов). |

**Пример `files`:**

```json
"files": [
  {
    "file": "profiles.json",
    "sheet_name": "Профили",
    "output": ["csv", "xlsx"],
    "path_starts": [["data", "body"], ["data", "body", "absences"]],
    "exclude_keys": ["photoData", "reactions", "colorCode"],
    "exclude_keys_in_path": [{"path": "full", "keys": ["info"]}],
    "column_order": ["empName", "empFamilyName", "jobTitle"]
  }
]
```

**Массивы объектов:** если значение поля — массив объектов `[{key: value}, ...]`, он разворачивается в **отдельные колонки** с индексом в имени: `родитель - ключ - (1)`, `родитель - ключ - (2)` и т.д. В ячейке — одно значение (не через запятую). **Порядок колонок:** сначала по ключу (первый сегмент пути): все колонки `agileManagers`, затем `agileRoles`, затем `agileTree` и т.д.; внутри каждого такого ключа — сначала все поля с индексом (1), затем (2), (3). Это позволяет держать блоки по смыслу (например все три колонки первого agileManager, затем второго).

**Исключение ключа только в определённом пути (`exclude_keys_in_path`):** правило `{"path": "agileManagers", "keys": ["id"]}` убирает поле `id` только внутри массива `agileManagers`; в других местах (например в `agileTree` или в корне) поле `id` остаётся. Удобно, чтобы убрать служебные UUID в одних блоках и оставить в других.

---

### CSV

| Параметр | Расположение | Примеры | Влияние |
|----------|--------------|---------|---------|
| **encoding** | `csv.encoding` | `"utf-8-sig"`, `"utf-8"`, `"cp1251"` | Кодировка файла. `utf-8-sig` даёт BOM для корректного открытия в Excel. |
| **delimiter** | `csv.delimiter` | `";"`, `","`, `"\t"` | Разделитель полей. `";"` удобен для локалей с запятой в числах. |
| **lineterminator** | `csv.lineterminator` | `"\n"`, `"\r\n"` | Окончание строки (Unix / Windows). |

---

### XLSX — общие параметры

| Параметр | Примеры | Влияние |
|----------|---------|---------|
| **freeze_first_row** | `true`, `false` | Если `true` и не задан `freeze_cell`, закрепление первой строки через ячейку `A2`. |
| **freeze_cell** | `"A2"`, `"B1"`, `"B2"`, `""` | Ячейка-граница закрепления по умолчанию для всех листов. `A2` — закрепить первую строку, `B1` — первый столбец, `B2` — и то и другое. Пусто — используется логика freeze_first_row. |
| **freeze_pane_per_sheet** | `[{"sheet_index":0,"cell":"B2"},{"sheet_index":1,"cell":"A2"}]` | Переопределение ячейки закрепления для указанных листов (sheet_index с 0). Для листа без записи используется freeze_cell. |
| **column_width_mode** | `"auto"`, `"minimum"`, `"maximum"` | **auto** — ширина по содержимому в пределах width_min..width_max из default_column_format; **minimum** — всегда width_min; **maximum** — всегда width_max. |
| **auto_row_height** | `true`, `false` | При `true` высота строк подбирается по содержимому (с учётом wrap_text). |
| **autofilter** | `true`, `false` | Включение автофильтра по первой строке. |

---

### XLSX — листы и форматирование

- **xlsx.sheets** — массив настроек листов. Каждый элемент:
  - **name** — отображаемое имя листа (до 31 символа). Пример: `"Профили"`, `"Лист1"`.
  - **columns** — список колонок для листа; пусто = все колонки.
  - **default_column_format** — формат по умолчанию для всех колонок листа (см. таблицу ниже).
  - **column_format** — объект «имя колонки → настройки», переопределяет default для указанных колонок. Пример: `{"gosbCode":{"number_format":"integer"},"groupingCode":{"number_format":"integer"}}`.

**Параметры default_column_format и column_format**

| Параметр | Относится к | Примеры | Влияние на результат |
|----------|-------------|---------|----------------------|
| **number_format** | общее | `"text"`, `"integer"` | **text** — ячейка как строка/общее (значение по умолчанию); **integer** — число отображается как целое. Если значение не преобразуется в указанный тип (например, в колонке integer лежит текст), ячейка остаётся в формате по умолчанию (текст) и со стилем по умолчанию. |
| **width_min** | общее | `8`, `10` | Минимальная ширина колонки (в единицах Excel). Используется при column_width_mode auto/minimum. |
| **width_max** | общее | `50`, `100` | Максимальная ширина колонки. Используется при column_width_mode auto/maximum. |
| **wrap_text** | общее | `true`, `false` | Перенос по словам в ячейке; при auto_row_height влияет на расчёт высоты строк. |
| **header_horizontal_align** | заголовок | `"left"`, `"center"`, `"right"` | Горизонтальное выравнивание текста в первой строке (заголовки). Применяется в XLSX. |
| **header_vertical_align** | заголовок | `"top"`, `"center"`, `"bottom"` | Вертикальное выравнивание заголовка. Применяется в XLSX. |
| **header_fg_color** | заголовок | `"000000"`, `"FFFFFF"`, `""` | Цвет текста заголовка (RRGGBB, без #). Пусто — по умолчанию (чёрный). Применяется. |
| **header_bg_color** | заголовок | `"C6EFCE"`, `""` | Заливка ячеек заголовка (RRGGBB). Пример C6EFCE — светло-салатовый. Применяется. |
| **header_bold** | заголовок | `true`, `false` | Жирный шрифт заголовка. Применяется. |
| **header_italic** | заголовок | `true`, `false` | Курсив заголовка. Зарезервировано (можно расширить). |
| **header_underline** | заголовок | `true`, `false` | Подчёркивание заголовка. Зарезервировано. |
| **data_horizontal_align** | данные | `"left"`, `"center"`, `"right"` | Горизонтальное выравнивание в ячейках данных. Применяется в XLSX. |
| **data_vertical_align** | данные | `"top"`, `"center"`, `"bottom"` | Вертикальное выравнивание в ячейках данных. Применяется в XLSX. |
| **data_fg_color** | данные | `"000000"`, `""` | Цвет текста в ячейках данных (RRGGBB). Применяется при задании. |
| **data_bg_color** | данные | `""`, `"E0E0E0"` | Заливка ячеек данных. Пусто — без заливки. Применяется при задании. |
| **data_bold** | данные | `true`, `false` | Жирный текст в данных. Применяется. |
| **data_italic** | данные | `true`, `false` | Курсив в данных. Применяется. |
| **data_underline** | данные | `true`, `false` | Подчёркивание в данных. Зарезервировано. |
| **float_decimals** | общее | `2` | Число знаков после запятой (зарезервировано). |
| **decimal_separator** | общее | `","` | Разделитель дробной части (зарезервировано). |
| **thousands_separator** | общее | `" "` | Разделитель тысяч (зарезервировано). |
| **date_format** | общее | `"DD.MM.YYYY"` | Формат даты (зарезервировано). |

**Пример фрагмента конфига листа с форматированием:**

```json
"sheets": [{
  "name": "Профили",
  "columns": [],
  "default_column_format": {
    "number_format": "text",
    "width_min": 10,
    "width_max": 100,
    "wrap_text": true,
    "header_horizontal_align": "left",
    "header_vertical_align": "center",
    "header_fg_color": "000000",
    "header_bg_color": "C6EFCE",
    "header_bold": true,
    "data_horizontal_align": "left",
    "data_vertical_align": "center",
    "data_fg_color": "000000",
    "data_bg_color": "",
    "data_bold": false,
    "data_italic": false
  },
  "column_format": {
    "gosbCode": { "number_format": "integer" },
    "groupingCode": { "number_format": "integer" }
  }
}]
```

В результате: первый лист будет называться «Профили», заголовки — жирные, с чёрным текстом и светло-салатовой заливкой, выравнивание заголовка и данных по горизонтали/вертикали из конфига; колонки `gosbCode` и `groupingCode` в XLSX будут отображаться как целые числа; ширина колонок — по режиму column_width_mode в пределах 10..100.

**Обработка исключений при форматировании колонок:** если для ячейки задан формат колонки (например `number_format: "integer"` или в будущем дата), но значение не удаётся преобразовать в этот тип (в ячейке текст, пустая строка, неверный формат даты и т.п.), ячейка записывается как значение по умолчанию (текст) и со стилем по умолчанию для данных, без применения формата колонки. Таким образом, «неподходящие» значения отображаются как есть, без искажения.

---

## Запуск и тесты

Из корня проекта:

```bash
python main.py
```

Конфиг по умолчанию: `./config.json`. Если в конфиге задан массив **`files`**, обрабатываются только файлы из `files[].file` (существующие в `input_dir`); иначе — из `input_files`.

Тесты развёртывания JSON:

```bash
python src/Tests/test_flattener.py
```

---

## История версий

- **0.4.1**
  - Разворот массивов объектов в отдельные колонки с индексом: имя колонки `родитель - ключ - (1)`, `(2)`, …; в ячейке — одно значение (не список через запятую).
  - Порядок колонок: по ключам (первый сегмент пути), внутри ключа — сначала все поля (1), затем (2), (3). Не смешиваются все (1) из разных массивов в кучу.
  - `exclude_keys_in_path` применяется и внутри массивов объектов: можно исключить, например, `id` только в `agileManagers`, оставив `id` в `agileTree`.
  - Тесты: test_array_of_objects_flatten (порядок (1) перед (2)), test_array_columns_grouped_by_key (два массива — блоки по ключам), test_exclude_keys_in_path_array.

- **0.4.0**
  - Настройки по файлам: опциональный массив `files` (file, sheet_name, output, path_start, path_starts, exclude_keys, exclude_keys_in_path, column_order). Если задан — список файлов и опции берутся из него.
  - Выбор выхода: для каждого файла можно указать `output`: только CSV, только XLSX или оба.
  - Имя листа в XLSX задаётся в конфиге (`sheet_name`) или по имени файла.
  - Несколько стартовых путей (`path_starts`): первый — источник строк, остальные — доп. данные мержатся в строку с префиксом.
  - Исключение ключей только внутри пути (`exclude_keys_in_path`): например убрать поле `info` только внутри раздела `full` (и внутри массивов объектов с таким путём).
  - Порядок колонок (`column_order`): указанные поля идут первыми на листе.
  - Разбор массивов объектов: колонки с индексом (1), (2), … по одному значению на колонку.
  - config_loader: get_files_list(), get_file_options(). worker: file_index, запись CSV только при "csv" в output. main: сбор листов только при "xlsx" в output.

- **0.3.1**
  - Обработка исключений при форматировании колонок: если значение не преобразуется в указанный тип (например integer или в будущем date), ячейка записывается как значение по умолчанию (текст) и со стилем по умолчанию, без применения формата колонки. Документация обновлена: правило fallback и описание _to_integer_value.

- **0.3.0**
  - Реализовано применение в XLSX: выравнивание заголовка и данных (header/data_horizontal_align, header/data_vertical_align), стиль данных (data_fg_color, data_bg_color, data_bold, data_italic), wrap_text в стилях. Стили собираются в styles.xml с элементами alignment; к ячейкам данных применяется отдельный стиль при задании любых параметров данных.
  - Документация: подробное описание работы программы, всех функций и конфига с примерами и вариантами значений.

- **0.2.0**
  - Закрепление областей по ячейке: freeze_cell и freeze_pane_per_sheet. Формат колонок: default_column_format и column_format (в т.ч. number_format: integer). Блок __comments в config.json. Режимы ширины колонок (column_width_mode), авто-высота строк (auto_row_height).

- **0.1.0**
  - Универсальный flatten JSON, path_start, exclude_keys, include_only_keys. Экспорт в CSV и один XLSX с листом на файл. Закрепление первой строки, автофильтр, формат «целое число». Логирование, параллельная обработка, только stdlib.
